<div>
    <div id="question">
        {{Front}}
    </div>
    <div id="options">
        {{Options}}
    </div>
    <div class="explain">
        {{Explain}}
    </div>
    <div id="answer" style="display:none">{{Answer}}</div>
</div>
<script>
    function init(){
        let originalAnswer = parseInt(document.getElementById("answer").textContent.trim(), 10);
        const question = document.getElementById("question");
        const explainDiv = document.querySelector(".explain");
        let optionElements = Array.from(document.querySelectorAll(".option"));

        // æ¸…ç†å¹¶å­˜å‚¨åŸå§‹æ–‡æœ¬
        optionElements.forEach((opt, i) => {
            opt.dataset.origIndex = String(i + 1);
            opt.textContent = opt.textContent.replace(/^\d+\.\s*/, '').trim();
        });

        // Fisher-Yates shuffle
        for (let i = optionElements.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [optionElements[i], optionElements[j]] = [optionElements[j], optionElements[i]];
        }

        // é‡æ–°æ’å…¥åˆ° DOM
        const optionsContainer = document.getElementById("options");
        optionsContainer.innerHTML = '';
        optionElements.forEach(opt => optionsContainer.appendChild(opt));

        // æ›´æ–° originalAnswer ä¸ºæ­£ç¡®é€‰é¡¹åœ¨æ‰“ä¹±åå¯¹åº”çš„æ˜¾ç¤ºä½ç½® (1-based)
        const correctOrigIndex = originalAnswer;
        const shuffledCorrectOpt = optionElements.find(opt => parseInt(opt.dataset.origIndex, 10) === correctOrigIndex);
        originalAnswer = optionElements.indexOf(shuffledCorrectOpt) + 1;

        const displayOptions = optionElements;
        displayOptions.forEach((opt, displayIdx) => {
            opt.dataset.selected = "false";
            opt.textContent = (displayIdx + 1) + ". " + opt.textContent;
            // Hover æ•ˆæœï¼šä»…åœ¨æœªè¢«é€‰ä¸­æ—¶ç”Ÿæ•ˆ
            opt.addEventListener('mouseenter', () => {
                if (opt.dataset.selected === "false") {
                    opt.style.backgroundColor = '#2c2c2c';
                }
            });
            opt.addEventListener('mouseleave', () => {
                if (opt.dataset.selected === "false") {
                    opt.style.backgroundColor = '#1e1e1e';
                }
            });
            // ç‚¹å‡»é€‰é¡¹
            opt.addEventListener('click', () => {
                window.speechSynthesis.cancel();
                displayOptions.forEach(o => {
                    o.style.backgroundColor = '#1e1e1e';
                    o.style.color = '#e0e0e0';
                    o.dataset.selected = "false";
                });
                const currentAnswer = originalAnswer;
                const isCorrect = (displayIdx + 1) === currentAnswer;
                if (isCorrect) {
                    opt.style.backgroundColor = '#1b5e20';
                    opt.style.color = '#a5d6a7';
                } else {
                    opt.style.backgroundColor = '#b71c1c';
                    opt.style.color = '#ffcccb';
                    const correctOpt = displayOptions[currentAnswer - 1];
                    if (correctOpt) {
                        correctOpt.style.backgroundColor = '#1b5e20';
                        correctOpt.style.color = '#a5d6a7';
                        correctOpt.dataset.selected = "true";
                    }
                }
                opt.dataset.selected = "true";
                explainDiv.style.display = 'block';
            });
        });
    }

    // âœ… ä¿è¯æ¯æ¬¡æ˜¾ç¤ºæ–°å¡æ—¶éƒ½é‡æ–°æœ—è¯»
    if (typeof ankiDeckObserverAttached === "undefined") {
        document.addEventListener("anki-show", init);
        window.ankiDeckObserverAttached = true;
    }

    // âœ… æ£€æµ‹åˆ‡æ¢åˆ°èƒŒé¢
    if (typeof ankiBackObserverAttached === "undefined") {
        const observer = new MutationObserver(() => {
            // const back = document.querySelector("#back");
            // if (back && back.offsetParent !== null) {
            //     const text = back.innerText || back.textContent;
            //     console.log("ğŸ¯ æ£€æµ‹åˆ°èƒŒé¢æ˜¾ç¤º:", text);
            //     // ğŸ‘‰ è¿™é‡Œæ‰§è¡Œä½ æƒ³è¦çš„æ“ä½œï¼ˆä¾‹å¦‚æœ—è¯»ã€æš‚åœéŸ³é¢‘ã€ä¿®æ”¹æ ·å¼ç­‰ï¼‰
            //     window.speechSynthesis.cancel();
            // }
        });
        observer.observe(document.body, {childList: true, subtree: true});
        window.ankiBackObserverAttached = true;
    }

    // ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼ˆç”¨äºé¦–å¼ å¡ç‰‡ï¼‰
    init()
</script>

<script>
    function setupTTS() {
        // æœ—è¯»æŒ‡å®šæ–‡æœ¬
        function speakText(text) {
            if (!text) return;

            // åœæ­¢å½“å‰æ’­æ”¾ï¼ˆé˜²æ­¢å †ç§¯ï¼‰
            window.speechSynthesis.cancel();

            const filteredText = filterText(text);
            const utterance = new SpeechSynthesisUtterance(filteredText);
            utterance.rate = 3.5;

            function findVoice() {
                const voices = window.speechSynthesis.getVoices();
                return voices.find(v =>
                    v.name === "Microsoft Yaoyao - Chinese (Simplified, PRC)" &&
                    v.lang === "zh-CN"
                );
            }

            // å°è¯•æ‰¾åˆ°æŒ‡å®šè¯­éŸ³
            let voice = findVoice();
            if (voice) {
                utterance.voice = voice;
                window.speechSynthesis.speak(utterance);
            } else {
                // ç­‰å¾…è¯­éŸ³åŠ è½½
                window.speechSynthesis.onvoiceschanged = () => {
                    voice = findVoice();
                    utterance.voice = voice || null;
                    utterance.lang = voice ? voice.lang : "zh-CN";
                    window.speechSynthesis.speak(utterance);
                    // ç§»é™¤ç›‘å¬å™¨ï¼Œé˜²æ­¢å¤šæ¬¡è§¦å‘
                    window.speechSynthesis.onvoiceschanged = null;
                };
            }
        }

        // è¿‡æ»¤æ–‡æœ¬å‡½æ•°
        function filterText(text) {
            let filtered = text // .split('\n')[0];
            filtered = filtered.replace(/[\(\[\{ã€ˆã€Šã€Œã€ã€].*?[\)\]\}ã€‰ã€‹ã€ã€ã€‘]/g, '');
            return filtered.trim();
        }

        // è·å–æ–‡æœ¬å†…å®¹
        const front = document.querySelector("#front");
        if (front) {
            const title = front.innerText || front.textContent;
            speakText(title);
        }
    }


</script>
